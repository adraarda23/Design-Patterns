================================================================================
                    BRIDGE DESIGN PATTERN - ASAMA ASAMA REHBER
================================================================================

Bu dokuman, Bridge Design Pattern'in nasil yazildigini adim adim aciklar.


================================================================================
ADIM 1: PROBLEMI ANLA
================================================================================

Diyelim ki bir "uzaktan kumanda" sistemi yaziyorsun.
- Farkli cihazlar var: TV, Radio, SmartSpeaker...
- Farkli kumanda turleri var: BasicRemote, AdvancedRemote, VoiceRemote...

YANLIS YAKLASIM (Inheritance Hell):
    BasicRemoteTv
    BasicRemoteRadio
    BasicRemoteSmartSpeaker
    AdvancedRemoteTv
    AdvancedRemoteRadio
    AdvancedRemoteSmartSpeaker
    VoiceRemoteTv
    VoiceRemoteRadio
    ...

3 kumanda x 3 cihaz = 9 sinif!
Yeni bir cihaz ekle = 3 yeni sinif daha!
Bu SINIF PATLAMASI (class explosion) problemidir.

DOGRU YAKLASIM (Bridge Pattern):
    Kumandalari ve cihazlari AYRI hiyerarsiler olarak tasarla.
    Aralarinda bir KOPRU (referans) kur.


================================================================================
ADIM 2: IMPLEMENTATION INTERFACE'INI OLUSTUR
================================================================================

Ilk olarak, "degisen" taraflardan birini soyutla.
Bizim ornegimizde cihazlar degisiyor, o yuzden Device interface'i yaziyoruz.

    public interface Device {
        boolean isEnabled();
        void enable();
        void disable();
        int getVolume();
        void setVolume(int volume);
        // ... diger metodlar
    }

NEDEN INTERFACE?
- Tum cihazlarin ortak davranislarini tanimlar
- Abstraction (RemoteControl) sadece bu interface'i bilir
- Yeni cihaz eklemek icin sadece bu interface'i implement et


================================================================================
ADIM 3: CONCRETE IMPLEMENTATION'LARI OLUSTUR
================================================================================

Device interface'ini implement eden somut siniflar yaz:

    public class Tv implements Device {
        private boolean on = false;
        private int volume = 30;

        @Override
        public void enable() { on = true; }

        @Override
        public void setVolume(int volume) {
            // TV'nin max sesi 100
            this.volume = Math.min(volume, 100);
        }
        // ... diger metodlar
    }

    public class Radio implements Device {
        // Radio'nun kendine ozgu implementasyonu
        // Ornegin max ses 50 olabilir
    }

DIKKAT:
- Her cihaz KENDI davranisini tanimlar
- Cihazlar RemoteControl hakkinda HICBIR SEY bilmez
- Tamamen bagimsiz calisabilirler


================================================================================
ADIM 4: ABSTRACTION SINIFINI OLUSTUR
================================================================================

Simdi koprunun diger tarafini (Abstraction) olustur:

    public class RemoteControl {

        // *** KOPRU BURADA! ***
        protected Device device;

        public RemoteControl(Device device) {
            this.device = device;  // Dependency Injection
        }

        public void togglePower() {
            if (device.isEnabled()) {
                device.disable();
            } else {
                device.enable();
            }
        }

        public void volumeUp() {
            device.setVolume(device.getVolume() + 10);
        }
    }

ONEMLI NOKTALAR:

1. "protected Device device" -> Bu KOPRU'dur!
   Abstraction, Implementation'a bu referans uzerinden ulasir.

2. Constructor Injection kullaniyoruz.
   Bu sayede runtime'da farkli cihazlar baglanabilir.

3. RemoteControl, TV veya Radio bilmiyor.
   Sadece Device interface'ini biliyor.


================================================================================
ADIM 5: REFINED ABSTRACTION'LARI OLUSTUR
================================================================================

Abstraction'i genislet, yeni ozellikler ekle:

    public class BasicRemote extends RemoteControl {
        public BasicRemote(Device device) {
            super(device);
        }
        // Temel islevleri kullanir
    }

    public class AdvancedRemote extends RemoteControl {
        public AdvancedRemote(Device device) {
            super(device);
        }

        // Ekstra ozellik
        public void mute() {
            device.setVolume(0);
        }
    }

DIKKAT:
- Yeni kumanda turleri, Device hakkinda detay bilmiyor
- Parent sinifin Device referansini kullaniyor
- Her kumanda kendi ekstra ozelliklerini ekleyebilir


================================================================================
ADIM 6: CLIENT CODE'U YAZ
================================================================================

Her seyi bir araya getir:

    public static void main(String[] args) {
        // Cihaz olustur
        Device tv = new Tv();

        // Kumandayi cihaza bagla
        AdvancedRemote remote = new AdvancedRemote(tv);

        // Kullan
        remote.togglePower();
        remote.volumeUp();
        remote.mute();

        // AYNI kumanda, FARKLI cihaz
        Device radio = new Radio();
        AdvancedRemote remote2 = new AdvancedRemote(radio);
        remote2.togglePower();
        remote2.mute();
    }


================================================================================
BRIDGE PATTERN'IN FAYDALARI
================================================================================

1. BAGIMSIZ GENISLEME
   - Yeni cihaz ekle: Device interface'ini implement et
   - Yeni kumanda ekle: RemoteControl'u extend et
   - Mevcut kod DEGISMEZ!

2. RUNTIME ESNEKLIGI
   - Ayni kumanda farkli cihazlarla calisabilir
   - Cihaz runtime'da degistirilebilir

3. SINGLE RESPONSIBILITY
   - RemoteControl: Kumanda mantigi
   - Device: Cihaz davranisi
   - Her sinif tek bir sorumluluga sahip

4. OPEN/CLOSED PRINCIPLE
   - Yeni tur eklemek icin mevcut kodu degistirmene gerek yok
   - Sisteme yeni siniflar EKLERSIN


================================================================================
NE ZAMAN BRIDGE KULLANMALIYIM?
================================================================================

1. Iki bagimsiz boyutta degisim varsa
   Ornek: Sekil + Renk, Platform + Uygulama, Kumanda + Cihaz

2. Sinif sayisi kontrolden cikiyorsa
   Ornek: 5 sekil x 5 renk = 25 sinif yerine 5 + 5 = 10 sinif

3. Implementation'i runtime'da degistirmek istiyorsan
   Ornek: Kullanici cihaz degistirdiginde

4. Implementation detaylarini gizlemek istiyorsan
   Ornek: Farkli veritabani driver'lari


================================================================================
BRIDGE vs ADAPTER vs STRATEGY
================================================================================

BRIDGE:
- Basindan itibaren AYRI tasarlanir
- Iki hiyerarsiyi bagimsiz gelisir
- Compile-time'da yapilir

ADAPTER:
- MEVCUT uyumsuz interfaceleri birlestir
- Genellikle tek yonlu
- Sonradan eklenir

STRATEGY:
- Algoritma ailesini degistirir
- Tek boyutlu degisim
- Davranis odakli


================================================================================
DOSYA YAPISI
================================================================================

Bridge/
├── Device.java           # Implementation Interface
├── Tv.java              # Concrete Implementation
├── Radio.java           # Concrete Implementation
├── RemoteControl.java   # Abstraction
├── BasicRemote.java     # Refined Abstraction
├── AdvancedRemote.java  # Refined Abstraction
├── Main.java            # Demo
└── ACIKLAMA.txt         # Bu dosya

================================================================================
